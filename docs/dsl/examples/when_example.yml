# =============================================================================
# Condition Syntax Guide - `when` Clause
# =============================================================================
#
# The `when` clause is used to define conditional logic in Pipeline DSL.
# It supports boolean expressions, logical operators (all/any/not), and
# arbitrary nesting for complex condition evaluation.
#
# =============================================================================
# Basic Syntax
# =============================================================================
#
# 1. Simple Boolean Expression:
#    A single boolean expression that evaluates to true or false.
#
# 2. Logical Operators:
#    - all:  All conditions must be true (AND logic)
#    - any:  At least one condition must be true (OR logic)
#    - not:  Negate the condition (NOT logic)
#
# 3. Nesting:
#    Logical operators can be nested arbitrarily to create complex conditions.
#
# =============================================================================
# Usage Contexts
# =============================================================================
#
# The `when` clause can be used in:
#   1. Pipeline-level: Filter events at pipeline entry
#   2. Step routes: Conditional routing between steps
#   3. Rule conditions: Evaluate rule execution conditions
#
# =============================================================================
# Examples
# =============================================================================

# -----------------------------------------------------------------------------
# Example 1: Simple Boolean Expression
# -----------------------------------------------------------------------------
# Single condition check
when: event.amount < 100

# -----------------------------------------------------------------------------
# Example 2: AND Logic (all conditions must be true)
# -----------------------------------------------------------------------------
when:
  all:
    - event.amount > 1000
    - event.geo.country in ["US", "CA"]
    - not:
        - features.risk_tags contains "proxy"

# -----------------------------------------------------------------------------
# Example 3: OR Logic (any condition can be true)
# -----------------------------------------------------------------------------
when:
  any:
    - vars.total_score >= 80
    - event.user.is_blacklisted == true

# -----------------------------------------------------------------------------
# Example 4: Complex Nested Conditions
# -----------------------------------------------------------------------------
# This example demonstrates complex risk assessment logic with multiple
# condition categories that can trigger high-risk review.
when:
  any:

    # -------------------------------------------------------
    # Category A: High Amount + High-Risk Country + Non-Whitelist
    # -------------------------------------------------------
    - all:
        - event.amount >= 3000
        - event.geo.country in ["NG", "PK", "UA", "RU"]
        - not:
            - event.user.tags contains "vip"

    # -------------------------------------------------------
    # Category B: Device/IP Anomaly + High Failure Frequency
    # -------------------------------------------------------
    - all:
        - any:
            - event.device.is_emulator == true
            - api.network_check.is_proxy == true
            - api.network_check.is_tor == true
        - features.login_fail_count_1h >= 3

    # -------------------------------------------------------
    # Category C: LLM Behavior Inference + User Profile Anomaly
    # -------------------------------------------------------
    - all:
        - api.llm_analysis.behavior.risk_level in ["high", "critical"]
        - any:
            - event.user.tags contains "abnormal_pattern"
            - event.user.tags contains "synthetic_identity"
            - event.user.tags contains "previous_fraud"

# =============================================================================
# Expression Operators
# =============================================================================
#
# Supported comparison operators:
#   - ==    : equality
#   - !=    : inequality
#   - >     : greater than
#   - >=    : greater than or equal
#   - <     : less than
#   - <=    : less than or equal
#   - in    : membership check (value in array)
#   - contains: string/array contains check
#
# Examples:
#   - event.amount == 100
#   - event.amount != 0
#   - event.amount > 1000
#   - event.amount >= 500
#   - event.amount < 100
#   - event.amount <= 50
#   - event.geo.country in ["US", "CA", "UK"]
#   - event.user.tags contains "vip"
#   - features.risk_tags contains "proxy"
#
# =============================================================================
# Context Variables
# =============================================================================
#
# Valid namespaces (as defined in docs/dsl/context.md):
#   - event.*     : Event data (e.g., event.amount, event.user.id, event.geo.country)
#   - features.*  : Complex computations (e.g., features.transaction_count_7d, features.risk_tags)
#   - api.*       : External API results (e.g., api.device_fingerprint.risk_score)
#   - service.*   : Internal service results (e.g., service.user_profile.vip_level)
#   - vars.*      : Simple variables (e.g., vars.total_score, vars.high_risk_threshold)
#   - sys.*       : System metadata (e.g., sys.request_id, sys.timestamp, sys.hour)
#   - env.*       : Environment config (e.g., env.api_timeout_ms, env.feature_flags.new_ml_model)
#   - results.*   : Ruleset results (e.g., results.fraud_detection.signal, results.decision)
#
# =============================================================================
# Best Practices
# =============================================================================
#
# 1. Readability:
#    - Use comments to explain complex condition groups
#    - Group related conditions together
#    - Use meaningful variable names
#
# 2. Performance:
#    - Place cheaper conditions first in `all` clauses
#    - Place more likely conditions first in `any` clauses
#    - Avoid deeply nested conditions when possible
#
# 3. Maintainability:
#    - Keep conditions focused and specific
#    - Document the business logic behind complex conditions
#    - Use consistent naming conventions
#
# 4. Testing:
#    - Test each condition branch independently
#    - Test edge cases (boundary values, null values)
#    - Test nested conditions at each level
#
# =============================================================================
# Common Patterns
# =============================================================================
#
# Pattern 1: Whitelist Check
#   when:
#     all:
#       - event.amount > vars.threshold
#       - not:
#           - event.user.tags contains "whitelist"
#
# Pattern 2: Blacklist Check
#   when:
#     any:
#       - event.user.is_blacklisted == true
#       - event.user.tags contains "fraud"
#
# Pattern 3: Risk Score Range
#   when:
#     all:
#       - vars.total_score >= 50
#       - vars.total_score < 80
#
# Pattern 4: Geographic Restriction
#   when:
#     all:
#       - event.geo.country not in ["US", "CA", "UK"]
#       - event.amount > 1000
#
# Pattern 5: Multiple Risk Indicators
#   when:
#     any:
#       - all:
#           - event.device.is_emulator == true
#           - features.login_fail_count_1h >= 3
#       - all:
#           - api.network_check.is_proxy == true
#           - event.amount > 5000
#
# =============================================================================

