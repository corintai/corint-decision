# =============================================================================
# Pipeline DSL Design Specification v2.0
# =============================================================================
#
# Design Goals:
#   1. DAG IR compilation friendly - explicit entry, unique IDs, clear edge relationships
#   2. Visualization friendly - distinguishable node types, clear routing conditions
#   3. LLM generation friendly - structured schema, clear constraints, rich examples
#
# =============================================================================
# Schema Definition (for compiler validation and LLM understanding)
# =============================================================================
#
# Pipeline:
#   id:          string (required, unique, snake_case)
#   name:        string (required, human readable)
#   description: string (optional)
#   version:     string (optional, semver format)
#   entry:       string (required, must match a step.id)
#   when:        Condition (optional, pipeline-level filter)
#   steps:       Step[] (required, non-empty)
#
# Step:
#   id:      string (required, unique within pipeline, snake_case)
#   name:    string (required, human readable)
#   type:    StepType (required)
#   ...type-specific fields...
#   routes:  Route[] (optional, conditional routing)
#   default: string (optional, default next step if no route matches)
#   next:    string | "end" (optional, unconditional next step)
#
# Route (consistent with registry format):
#   next:    string (required, target step id or "end")
#   when:    Condition (required, jump to next when condition is met)
#
# Output Convention (Convention over Configuration):
#   - router:       no return value, pure routing dispatch, does not affect context
#   - function:     result automatically stored in function.<function_name>
#   - api:          result automatically stored in api.<api_name>
#   - service:      result automatically stored in service.<service_name>
#   - rule/ruleset: directly affects score/decision, no output needed
#   - pipeline:     sub-pipeline context changes automatically merged back to main pipeline
#   - trigger:      no return value, does not affect context
#
# StepType (what to execute):
#   - router   : pure routing judgment (no computation, only dispatch based on routes conditions)
#   - function : internal pure function computation (result stored in function.<name>, for subsequent steps)
#   - rule     : execute single rule
#   - ruleset  : execute ruleset
#   - pipeline : call sub-pipeline
#   - service  : internal service call (DB, Redis, internal API)
#   - api      : external API call (third-party service)
#   - trigger  : trigger external action (MQ, Webhook, notification)
#
# Execution Mode (how to execute - only api/service types support):
#   - (default)  : execute single target
#   - any:       : try sequentially, use first successful one (fallback mode)
#   - all:       : execute all in parallel, wait for all to complete (aggregation mode)
#
# Condition (unified condition format, supports arbitrary nesting):
#   Basic format:
#     - string: single boolean expression (e.g., "event.amount > 100")
#     - { all: [...] }: all conditions must be true (AND)
#     - { any: [...] }: at least one condition is true (OR)
#     - { not: [...] }: condition negation (NOT)
#     - supports arbitrary nesting: all/any/not can nest each other
#
#   Route format (consistent with registry: target outside, condition inside):
#     routes:
#       - next: vip_fast_track
#         when:
#           all:
#             - event.amount > 10000
#             - event.user.vip_status == true
#       - next: high_value_flow
#         when:
#           all:
#             - event.amount > 1000
#     default: standard_scoring
#
# =============================================================================
# Compiler Validation Rules
# =============================================================================
#
# E001: entry must point to an existing step.id
# E002: all step.id must be unique
# E003: routes[].next and default/next must point to existing step.id or "end"
# E004: cannot have unreachable steps (unreachable nodes)
# E005: cannot have circular references forming infinite loops (unless explicitly marked as loop)
# E006: type-specific required field validation:
#       - router:   routes (required, routing condition list)
#       - function: function (required)
#       - rule:     rule (required)
#       - ruleset:  ruleset (required)
#       - pipeline: pipeline or inline (required)
#       - service:  service (required)
#       - api:      api or any/all (required)
#       - trigger:  target (required)
# E007: terminal nodes must have next: end or no subsequent routes
#
# W001: step is not referenced by any other step (except entry)
# W002: routes[].when condition may never be satisfied
# W003: recommend adding default to handle unmatched cases
#
# =============================================================================

version: "1.0"

import:
  rulesets:
    - library/rulesets/payment_high_value.yaml
    - library/rulesets/payment_standard.yaml
  pipelines:
    - library/pipelines/high_value_verification.yaml

pipeline:
  id: payment_risk_pipeline
  name: Payment Risk Control Pipeline
  description: Comprehensive payment risk assessment with conditional routing
  version: "1.0.0"

  # Explicit entry point (required for DAG IR compilation)
  entry: get_ip_info

  # Pipeline entry condition (coarse-grained filtering, scheduled by Registry)
  when:
    all:
      - event.channel == "stripe"
      - event.amount < 50000

  # Execution steps
  steps:
    # =========================================================================
    # Step: get_ip_info
    # Type: api (external API call)
    # =========================================================================
    - step:
        id: get_ip_info
        name: Get IP Geolocation
        type: api
        api: ip_geolocation
        params:
          ip: event.ip_address
        # output: api.ip_geolocation (convention: api.<api_name>)
        routes:
          - next: check_amount
            when:
              all:
                - api.ip_geolocation.country_code == "US"
          - next: cn_verification
            when:
              all:
                - api.ip_geolocation.country_code == "CN"
          - next: manual_review
            when:
              all:
                - api.ip_geolocation.risk_level == "high"
        default: standard_check

    # =========================================================================
    # Step: check_amount
    # Type: router (pure routing judgment, routes format consistent with registry)
    # Supports arbitrary nesting of all/any/not
    # =========================================================================
    - step:
        id: check_amount
        name: Check Transaction Amount
        type: router
        routes:
          # Complex condition example: high value + VIP user goes to fast track
          - next: vip_fast_track
            when:
              all:
                - event.amount > 10000
                - event.user.vip_status == true
          # Simple condition example
          - next: high_value_flow
            when:
              all:
                - event.amount > 1000
        default: standard_scoring

    # =========================================================================
    # Step: cn_verification
    # Type: ruleset (ruleset execution)
    # =========================================================================
    - step:
        id: cn_verification
        name: China Region Verification
        type: ruleset
        ruleset: cn_region_rules
        next: standard_scoring

    # =========================================================================
    # Step: vip_fast_track
    # Type: ruleset (VIP fast track)
    # =========================================================================
    - step:
        id: vip_fast_track
        name: VIP Fast Track
        type: ruleset
        ruleset: vip_fast_rules
        next: decision_point

    # =========================================================================
    # Step: high_value_flow
    # Type: pipeline (sub-pipeline call)
    # =========================================================================
    - step:
        id: high_value_flow
        name: High Value Transaction Flow
        type: pipeline
        pipeline: high_value_verification
        next: final_scoring

    # =========================================================================
    # Step: standard_scoring
    # Type: ruleset (ruleset execution)
    # =========================================================================
    - step:
        id: standard_scoring
        name: Standard Risk Scoring
        type: ruleset
        ruleset: payment_standard
        next: decision_point

    # =========================================================================
    # Step: final_scoring
    # Type: ruleset (ruleset execution)
    # =========================================================================
    - step:
        id: final_scoring
        name: Final Risk Scoring
        type: ruleset
        ruleset: payment_high_value
        next: decision_point

    # =========================================================================
    # Step: standard_check
    # Type: ruleset (default path)
    # =========================================================================
    - step:
        id: standard_check
        name: Standard Check
        type: ruleset
        ruleset: payment_standard
        next: decision_point

    # =========================================================================
    # Step: decision_point
    # Type: router (decision routing based on score)
    # =========================================================================
    - step:
        id: decision_point
        name: Decision Point
        type: router
        # sys.total_score is the total score calculated by the system after rule execution
        routes:
          - next: auto_approve
            when:
              all:
                - sys.total_score >= 80
          - next: auto_reject
            when:
              all:
                - sys.total_score <= 20
        default: manual_review

    # =========================================================================
    # Step: auto_approve
    # Type: trigger (terminal action)
    # =========================================================================
    - step:
        id: auto_approve
        name: Auto Approve
        type: trigger
        target: approval_service
        params:
          decision: approve
          reason: "Low risk score"
        next: end

    # =========================================================================
    # Step: auto_reject
    # Type: trigger (terminal action)
    # =========================================================================
    - step:
        id: auto_reject
        name: Auto Reject
        type: trigger
        target: rejection_service
        params:
          decision: reject
          reason: "High risk score"
        next: notify_user

    # =========================================================================
    # Step: manual_review
    # Type: trigger (terminal action)
    # =========================================================================
    - step:
        id: manual_review
        name: Send to Manual Review
        type: trigger
        target: case_management
        params:
          queue: "risk_review"
          priority: sys.total_score < 40 ? "high" : "normal"
        next: end

    # =========================================================================
    # Step: notify_user
    # Type: trigger (notification)
    # =========================================================================
    - step:
        id: notify_user
        name: Notify User
        type: trigger
        target: notification_service
        params:
          channel: email
          template: "payment_rejected"
          user_id: event.user_id
        next: end

# =============================================================================
# Sub-Pipeline Reference Methods
# =============================================================================
#
# Method 1: Separate file + imports (recommended)
# --------------------------------
# imports:
#   pipelines:
#     - library/pipelines/high_value_verification.yaml
#
# - step:
#     type: pipeline
#     pipeline: high_value_verification
#
# Method 2: Inline definition (simple scenarios)
# --------------------------
# - step:
#     id: inline_flow
#     type: pipeline
#     inline:
#       entry: step1
#       steps:
#         - step:
#             id: step1
#             type: api
#             ...
#
# =============================================================================
# Execution Mode Examples (api/service specific)
# =============================================================================
#
# any mode - fallback/alternative (try sequentially, return first successful)
# ------------------------------------------------
# - step:
#     id: get_ip_info
#     type: api
#     any:
#       - maxmind_api         # primary
#       - ipinfo_api          # fallback 1
#       - ip2location_api     # fallback 2
#     params:
#       ip: event.ip_address
#     # Result automatically stored in: api.{api_name}.{endpoint}
#     next: next_step
#
# all mode - aggregation (execute in parallel, wait for all to complete)
# ----------------------------------------
# - step:
#     id: fetch_external_data
#     type: api
#     all:
#       - credit_bureau_api
#       - fraud_detection_api
#       - identity_verification_api
#     timeout: 5s              # total timeout
#     on_error: partial        # partial | fail_fast
#     min_success: 2           # minimum success count (valid when on_error: partial)
#     # Result automatically stored in: api.{api_name}.{endpoint}
#     next: scoring
#
# =============================================================================
# DAG Visualization Reference (auto-generated)
# =============================================================================
#
#                        ┌─────────────────┐
#                        │  get_ip_info    │ ← entry
#                        │   [api]         │
#                        └────────┬────────┘
#                                 │
#          ┌──────────────────────┼──────────────────────┐
#          │ US                   │ CN                   │ high_risk / default
#          ▼                      ▼                      ▼
#  ┌───────────────┐      ┌───────────────┐      ┌───────────────┐
#  │ check_amount  │      │cn_verification│      │ manual_review │
#  │ [expression]  │      │  [ruleset]    │      │standard_check │
#  └───────┬───────┘      └───────┬───────┘      └───────┬───────┘
#          │                      │                      │
#    ┌─────┴─────┐                │                      │
#    │>1000      │≤1000           │                      │
#    ▼           ▼                │                      │
# ┌─────────┐ ┌─────────────┐     │                      │
# │high_val │ │standard_    │◄────┘                      │
# │ _flow   │ │scoring      │◄───────────────────────────┘
# │[pipeline]│ │[ruleset]   │
# └────┬────┘ └──────┬──────┘
#      │             │
#      ▼             │
# ┌─────────┐        │
# │final_   │        │
# │scoring  │        │
# │[ruleset]│        │
# └────┬────┘        │
#      │             │
#      └──────┬──────┘
#             ▼
#     ┌───────────────┐
#     │decision_point │
#     │ [expression]  │
#     └───────┬───────┘
#             │
#    ┌────────┼────────┐
#    │≥80     │20-80   │≤20
#    ▼        ▼        ▼
# ┌──────┐ ┌──────┐ ┌──────┐
# │auto_ │ │manual│ │auto_ │
# │approve│ │review│ │reject│
# │[trigger]│[trigger]│[trigger]│
# └──┬───┘ └──┬───┘ └──┬───┘
#    │        │        │
#    ▼        ▼        ▼
#   END      END   notify_user
#                  │[trigger]│
#                  └────┬────┘
#                       ▼
#                      END
#
# =============================================================================
# LLM Generation Guidelines
# =============================================================================
#
# When generating Pipeline, please follow these constraints:
#
# 1. Structure constraints:
#    - Must include id, name, entry, steps
#    - entry must point to an existing step.id in steps
#    - each step must have a unique id
#
# 2. Naming constraints:
#    - id: snake_case, describe functionality (e.g., check_amount, get_ip_info)
#    - name: human-readable description (e.g., "Check Transaction Amount")
#
# 3. Routing constraints:
#    - terminal nodes use next: end
#    - conditional routing uses routes + default (consistent with registry format)
#    - unconditional jump uses next: <step_id>
#
# 4. Condition format (routes consistent with registry format: target outside, condition inside):
#    Simple condition - AND (all conditions must be satisfied):
#      routes:
#        - next: high_value_flow
#          when:
#            all:
#              - event.amount > 1000
#
#    Simple condition - OR (any condition satisfied):
#      routes:
#        - next: domestic_flow
#          when:
#            any:
#              - event.country == "US"
#              - event.country == "CA"
#
#    Negation condition - NOT:
#      routes:
#        - next: clean_flow
#          when:
#            all:
#              - event.amount > 5000
#              - not:
#                  - risk.tags contains "proxy"
#
#    Nested conditions (complex boolean logic):
#      routes:
#        - next: high_risk_review
#          when:
#            any:
#              - all:
#                  - event.amount >= 3000
#                  - geo.country in ["NG", "PK", "UA"]
#              - all:
#                  - device.is_emulator == true
#                  - risk.login_fail_count_1h >= 3
#
# 5. Type selection:
#    - pure conditional dispatch → router (no computation, only select next step based on conditions)
#    - internal pure computation → function (compute complex values for subsequent reuse, stored in function.<name>)
#    - execute business rules → rule/ruleset
#    - call sub-pipeline → pipeline
#    - query internal data → service (has I/O, stored in service.<name>)
#    - call external API → api (has I/O, stored in api.<name>)
#    - send notification/write to queue → trigger
#
#    function vs service vs api comparison:
#    | Type     | I/O | Storage Location      | Purpose                    |
#    |----------|-----|-----------------------|----------------------------|
#    | function | No  | function.<name>       | pure computation/feature engineering |
#    | service  | Yes | service.<name>       | internal service (DB/Redis) |
#    | api      | Yes | api.<name>           | external third-party service |
#
# 6. Visualization friendly:
#    - maintain top-to-bottom, left-to-right reading order
#    - place related steps together
#    - place terminal nodes at the end
#

